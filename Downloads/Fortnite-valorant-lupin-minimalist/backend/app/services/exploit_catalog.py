from datetime import datetime
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, desc

from app.models import Exploit


async def generate_next_pie_id(db: AsyncSession) -> str:
    """Generate the next PIE ID (PIE-YYYY-XXX)."""
    year = datetime.utcnow().year
    result = await db.execute(
        select(Exploit.cve_id)
        .where(Exploit.cve_id.like(f"PIE-{year}-%"))
        .order_by(desc(Exploit.cve_id))
        .limit(1)
    )
    latest = result.scalar()

    if latest:
        try:
            num = int(latest.split("-")[-1])
        except ValueError:
            num = 0
        next_num = num + 1
    else:
        next_num = 1

    return f"PIE-{year}-{next_num:03d}"


async def record_lupin_discovery(
    db: AsyncSession,
    prompt: str,
    model_name: Optional[str],
    model_response: Optional[str],
    severity: str = "high"
) -> Optional[Exploit]:
    """
    Persist a newly discovered jailbreak prompt as an Exploit.

    Returns existing exploit if prompt already recorded.
    """
    cleaned_prompt = (prompt or "").strip()
    if not cleaned_prompt:
        return None

    result = await db.execute(
        select(Exploit).where(Exploit.exploit_content == cleaned_prompt)
    )
    existing = result.scalar_one_or_none()
    if existing:
        return existing

    cve_id = await generate_next_pie_id(db)
    exploit = Exploit(
        cve_id=cve_id,
        title=f"Lupin Auto Discovery - {model_name or 'Unknown Model'}",
        description="Automatically captured jailbreak discovered by Lupin during interactive testing.",
        exploit_content=cleaned_prompt,
        exploit_type="jailbreak",
        severity=severity,
        source="Lupin Auto Discovery",
        source_type="auto_agent",
        target_models=[model_name] if model_name else None,
        mitigation="Pending triage",
        status="active",
        discovered_date=datetime.utcnow(),
        extra_data={
            "auto_discovered": True,
            "model_response_preview": (model_response or "")[:1000]
        }
    )
    db.add(exploit)
    await db.commit()
    await db.refresh(exploit)
    return exploit
