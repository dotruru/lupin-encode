"""
Migration script to clean up existing exploits and separate description from exploit content
"""
import asyncio
import re
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.database import async_session_maker
from app.models import Exploit


async def clean_exploit_formatting():
    """Clean up existing exploits to separate description from jailbreak prompts"""
    async with async_session_maker() as db:
        # Get all exploits
        result = await db.execute(select(Exploit))
        exploits = result.scalars().all()

        print(f"Found {len(exploits)} exploits to clean up...")
        updated_count = 0

        for exploit in exploits:
            original_desc = exploit.description or ""
            original_content = exploit.exploit_content or ""

            # Skip if already properly formatted (has separate exploit_content)
            if original_content and len(original_content) > 50 and original_content != original_desc:
                print(f"  ✓ Already clean: {exploit.cve_id} - {exploit.title[:40]}")
                continue

            # Parse the combined description to extract exploit prompt
            exploit_content = ""
            clean_description = original_desc

            # Look for code blocks (prompts are usually in code blocks)
            code_blocks = re.findall(r'```(?:xml|python|bash|text)?\n?(.*?)```', original_desc, re.DOTALL)
            if code_blocks:
                exploit_content = "\n\n".join(code_blocks).strip()
                # Remove code blocks from description
                clean_description = re.sub(r'```(?:xml|python|bash|text)?.*?```', '', original_desc, flags=re.DOTALL)

            # Look for "Exploit Prompt/Payload" sections
            prompt_match = re.search(r'\*\*Exploit Prompt[:/]?(?:Payload)?\*\*\s*[:\n]+(.*?)(?=\n\s*-\s*\*\*|\n\n---|\Z)', original_desc, re.DOTALL | re.IGNORECASE)
            if prompt_match:
                prompt_text = prompt_match.group(1).strip()
                prompt_text = re.sub(r'^```(?:xml|python|bash|text)?\n?', '', prompt_text)
                prompt_text = re.sub(r'\n?```$', '', prompt_text)
                if not exploit_content:
                    exploit_content = prompt_text
                elif prompt_text and prompt_text not in exploit_content:
                    exploit_content += "\n\n" + prompt_text
                # Remove from description
                clean_description = re.sub(r'\*\*Exploit Prompt[:/]?(?:Payload)?\*\*.*?(?=\n\s*-\s*\*\*|\n\n---|\Z)', '', clean_description, flags=re.DOTALL | re.IGNORECASE)

            # Extract structured description parts
            desc_parts = []

            # Extract description field
            desc_match = re.search(r'\*\*Description[:\s]+\*\*\s*(.*?)(?=\n\s*-\s*\*\*|\Z)', clean_description, re.DOTALL | re.IGNORECASE)
            if desc_match:
                desc_parts.append(desc_match.group(1).strip())

            # Extract type
            type_match = re.search(r'\*\*Type[:\s]+\*\*\s*(.*?)(?=\n\s*-\s*\*\*|\Z)', clean_description, re.DOTALL | re.IGNORECASE)
            if type_match:
                desc_parts.append(f"Type: {type_match.group(1).strip()}")

            # Extract severity
            severity_match = re.search(r'\*\*Severity[:\s]+\*\*\s*(.*?)(?=\n\s*-\s*\*\*|\Z)', clean_description, re.DOTALL | re.IGNORECASE)
            if severity_match:
                desc_parts.append(f"Severity: {severity_match.group(1).strip()}")

            # Extract affected models
            models_match = re.search(r'\*\*Affected Models[:\s]+\*\*\s*(.*?)(?=\n\s*-\s*\*\*|\Z)', clean_description, re.DOTALL | re.IGNORECASE)
            if models_match:
                desc_parts.append(f"Affected Models: {models_match.group(1).strip()}")

            final_description = "\n\n".join(desc_parts) if desc_parts else clean_description

            # Clean up description
            final_description = re.sub(r'\n\s*-\s*\*\*[^*]+\*\*', '', final_description)
            final_description = re.sub(r'\s+', ' ', final_description).strip()
            final_description = final_description[:1000]  # Limit length

            # Update if we found exploit content or cleaned up description
            if exploit_content or final_description != original_desc:
                exploit.description = final_description or "No description available"
                exploit.exploit_content = exploit_content[:2000] if exploit_content else ""
                updated_count += 1
                print(f"  ✓ Updated: {exploit.cve_id} - {exploit.title[:40]}")
                print(f"    Description length: {len(final_description)}")
                print(f"    Exploit content length: {len(exploit_content)}")

        await db.commit()
        print(f"\n✅ Cleaned up {updated_count} exploits successfully!")


if __name__ == "__main__":
    asyncio.run(clean_exploit_formatting())
